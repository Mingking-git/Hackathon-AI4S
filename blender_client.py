import socket
import json
import os
import time

import logging

# Set up logging (this just prints messages to your terminal for debugging)
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(name)s - %(message)s'
)
logger = logging.getLogger(__name__)

# --- Configuration ---
BLENDER_HOST = 'localhost'
BLENDER_PORT = 9876


# --- AI Integration Point ---

def call_ai_text_to_3d_api(prompt):
    """
    *** THIS IS A SIMULATED FUNCTION ***
    Replace the contents of this function with your actual API call
    to a Text-to-3D service.

    Args:
        prompt (str): The text description of the model to generate.

    Returns:
        str: The absolute filepath to the generated 3D model file (e.g., .obj).
             Returns None if generation fails.
    """
    logger.info("\n----------------------------------------------------")
    logger.info(f"[AI SIMULATION] Received prompt: '{prompt}'")
    logger.info("[AI SIMULATION] Calling Text-to-3D API... (simulating a 3-second wait)")
    time.sleep(3)

    # For this simulation, we will create a simple dummy OBJ file.
    # A real implementation would download this file from the AI service.
    # An .obj file is a simple text file defining vertices and faces.
    dummy_obj_content = (
        "# Dummy model generated by AI Simulation\n"
        "v 1.0 1.0 -1.0\n"
        "v 1.0 -1.0 -1.0\n"
        "v 1.0 1.0 1.0\n"
        "v 1.0 -1.0 1.0\n"
        "v -1.0 1.0 -1.0\n"
        "v -1.0 -1.0 -1.0\n"
        "v -1.0 1.0 1.0\n"
        "v -1.0 -1.0 1.0\n"
        "f 1 2 4 3\n"
        "f 3 4 8 7\n"
        "f 7 8 6 5\n"
        "f 5 6 2 1\n"
        "f 1 3 7 5\n"
        "f 2 4 8 6\n"
    )

    try:
        # Get the directory where this script is running
        script_dir = os.path.dirname(os.path.abspath(__file__))
        filepath = os.path.join(script_dir, "generated_model.obj")

        with open(filepath, "w") as f:
            f.write(dummy_obj_content)

        logger.info(f"[AI SIMULATION] Successfully created dummy model at: {filepath}")
        logger.info("----------------------------------------------------\n")
        return filepath

    except Exception as e:
        logger.error(f"[AI SIMULATION] Error creating dummy file: {e}")
        return None


def send_command_to_blender(command_payload):
    """
    Connects to the Blender server and sends a command payload as JSON.
    """
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            logger.info(f"Connecting to Blender at {BLENDER_HOST}:{BLENDER_PORT}...")
            s.connect((BLENDER_HOST, BLENDER_PORT))
            command_json = json.dumps(command_payload)
            s.sendall(command_json.encode('utf-8'))
            logger.info(f"Sent JSON: {command_json}")
            response = s.recv(1024)
            logger.info(f"Response from Blender: {response.decode('utf-8')}")
    except ConnectionRefusedError:
        logger.error("Connection refused. Make sure the server is running in Blender.")
    except Exception as e:
        logger.error(f"An error occurred: {e}")


def main():
    """
    Main loop to get user input and send it to Blender as a JSON object.
    """
    print("--- MCP Server for Blender (AI Edition) ---")
    print("Commands:")
    print("  'cube', 'sphere', 'snowman' - for procedural objects")
    print("  'ai <your prompt>'          - to generate a model with AI")
    print("  'exit'                      - to quit")

    while True:
        user_input = input("\nEnter command > ").lower()
        command_payload = None

        if user_input == 'exit':
            break

        if user_input.startswith("ai "):
            prompt = user_input[3:].strip()
            if not prompt:
                print("Error: AI prompt cannot be empty.")
                continue

            # 1. Call the (simulated) AI API
            model_filepath = call_ai_text_to_3d_api(prompt)

            # 2. If successful, create the command for Blender
            if model_filepath:
                command_payload = {
                    "command": "import_model",
                    "params": {
                        "filepath": model_filepath
                    }
                }
            else:
                print("Could not generate model. Aborting command.")

        elif user_input == 'cube':
            command_payload = {"command": "create_cube", "params": {"size": 2, "location": [0, 0, 1]}}
        elif user_input == 'sphere':
            command_payload = {"command": "create_sphere", "params": {"radius": 1, "location": [0, 0, 1]}}
        elif user_input == 'snowman':
            command_payload = {"command": "create_snowman"}
        else:
            print("Unknown command.")

        if command_payload:
            send_command_to_blender(command_payload)


if __name__ == '__main__':
    params = {
        "python_script": "\nimport bpy\n\n# --- 1. Scene Setup ---\n# Clear existing objects for a clean start\nbpy.ops.object.select_all(action='SELECT')\nbpy.ops.object.delete(use_global=False)\n\n# Add a ground plane\nbpy.ops.mesh.primitive_plane_add(size=10, enter_editmode=False, align='WORLD', location=(0, 0, -0.05))\nbpy.context.active_object.name = 'Ground'\n\n# Add a light source for rendering\nbpy.ops.object.light_add(type='SUN', align='WORLD', location=(0, 0, 10))\nlight_object = bpy.context.active_object\nlight_object.data.energy = 5\nlight_object.rotation_euler[0] = 0.8 # Tilt the sun for nice shadows\nlight_object.rotation_euler[1] = 0.5\n\n# Add and position the camera\nbpy.ops.object.camera_add(location=(5, -5, 4), rotation=(1.2, 0, 0.8))\ncamera_object = bpy.context.active_object\nbpy.context.scene.camera = camera_object\n\n# --- 2. Create the Visual Water Tank ---\n# Create the main cube for the tank\nbpy.ops.mesh.primitive_cube_add(size=2, enter_editmode=False, align='WORLD', location=(0, 0, 1))\ntank_object = bpy.context.active_object\ntank_object.name = 'WaterTank'\n\n# Cut a hole in the top to make it a container\nbpy.ops.object.mode_set(mode='EDIT')\nbpy.ops.mesh.select_mode(type='FACE')\nbpy.ops.mesh.select_all(action='DESELECT')\nbpy.ops.object.mode_set(mode='OBJECT')\n# Select the top face (face with the highest Z coordinate)\ntank_object.data.polygons[5].select = True \nbpy.ops.object.mode_set(mode='EDIT')\nbpy.ops.mesh.delete(type='FACES')\n\n# Add a Solidify modifier to give the walls thickness\nbpy.ops.object.mode_set(mode='OBJECT')\nbpy.ops.object.modifier_add(type='SOLIDIFY')\ntank_object.modifiers['Solidify'].thickness = 0.05\n\n# Create a simple glass material for the tank\nglass_material = bpy.data.materials.new(name='GlassMaterial')\nglass_material.use_nodes = True\nprincipled_bsdf = glass_material.node_tree.nodes.get('Principled BSDF')\nif principled_bsdf:\n principled_bsdf.inputs['Transmission'].default_value = 1.0\n principled_bsdf.inputs['Roughness'].default_value = 0.05\n principled_bsdf.inputs['IOR'].default_value = 1.45\ntank_object.data.materials.append(glass_material)\n\n\n# --- 3. Setup the Fluid Simulation ---\n# Create the fluid domain object (slightly larger than the tank)\nbpy.ops.mesh.primitive_cube_add(size=2.1, enter_editmode=False, align='WORLD', location=(0, 0, 1.05))\ndomain_object = bpy.context.active_object\ndomain_object.name = 'FluidDomain'\ndomain_object.display_type = 'WIRE' # Make it invisible in viewport, only show wireframe\n\n# Add and configure the fluid domain physics\nbpy.ops.object.modifier_add(type='FLUID')\nfluid_modifier = domain_object.modifiers['Fluid']\nfluid_modifier.fluid_type = 'DOMAIN'\ndomain_settings = fluid_modifier.domain_settings\ndomain_settings.domain_type = 'LIQUID'\ndomain_settings.resolution_max = 96 # Increased resolution for more detail\ndomain_settings.use_mesh = True # Generate a renderable mesh for the fluid\ndomain_settings.cache_type = 'ALL'\n\n# Create the inflow object (water source)\nbpy.ops.mesh.primitive_uv_sphere_add(radius=0.2, location=(0, 0, 2))\ninflow_object = bpy.context.active_object\ninflow_object.name = 'WaterInflow'\n\n# Add and configure the fluid flow physics\nbpy.ops.object.modifier_add(type='FLUID')\ninflow_modifier = inflow_object.modifiers['Fluid']\ninflow_modifier.fluid_type = 'FLOW'\ninflow_modifier.flow_settings.flow_type = 'LIQUID'\ninflow_modifier.flow_settings.flow_behavior = 'INFLOW'\ninflow_modifier.flow_settings.use_initial_velocity = True\ninflow_modifier.flow_settings.velocity_coord[2] = -3.0\n\n# --- 4. Create Water Material ---\nwater_material = bpy.data.materials.new(name='WaterMaterial')\nwater_material.use_nodes = True\nprincipled_bsdf_water = water_material.node_tree.nodes.get('Principled BSDF')\nif principled_bsdf_water:\n principled_bsdf_water.inputs['Transmission'].default_value = 1.0\n principled_bsdf_water.inputs['Roughness'].default_value = 0.1\n principled_bsdf_water.inputs['IOR'].default_value = 1.333 # IOR of water\n# Assign the water material to the domain object. It will be automatically applied to the fluid mesh.\ndomain_object.data.materials.append(water_material)\n\n# --- 5. Simulation and Rendering ---\nscene = bpy.context.scene\nscene.frame_end = 150 # Longer animation\nscene.render.engine = 'CYCLES' # Use Cycles for more realistic rendering\nscene.cycles.device = 'GPU' # Use GPU if available\nscene.cycles.samples = 128 # Lower samples for faster rendering\nscene.render.image_settings.file_format = 'FFMPEG'\nscene.render.ffmpeg.format = 'MPEG4'\nscene.render.filepath = '/tmp/detailed_water_simulation.mp4'\n\n# Bake the simulation\nbpy.ops.fluid.bake_all()\n\n# Handler to automatically start rendering after baking is complete\ndef render_on_bake_complete(scene):\n if scene.frame_current == scene.frame_end:\n print('Bake finished. Starting render.')\n bpy.ops.render.render(animation=True)\n bpy.app.handlers.frame_change_post.remove(render_on_bake_complete)\n\nbpy.app.handlers.frame_change_post.append(render_on_bake_complete)\n\n# Set the current frame to the end to initiate the process\nbpy.context.scene.frame_current = bpy.context.scene.frame_end\n"
    }
    params = {
        "python_script": "bpy.ops.mesh.primitive_cube_add(size=2, enter_editmode=False, align='WORLD', location=[0, 0, 1])"
    }
    # send_command_to_blender({"command": "create_cube", "params": {"size": 2, "location": [0, 0, 1]}})
    script1 = "bpy.ops.mesh.primitive_cube_add(size=2, enter_editmode=False, align='WORLD', location=[0, 0, 1])"
    script2 = '''
import bpy
import math
bpy.ops.mesh.primitive_cone_add(vertices=3, radius1=1.0, radius2=0.0, depth=math.sqrt(2), end_fill_type='TRIFAN', location=(0, 0, 0))
    '''
    # send_command_to_blender({"command": "python", "params": {"script": script1}})
    script = params.get("python_script")
    script = script.strip()
    send_command_to_blender({"command": "run_physics_simulation", "params": {"script": script}})
